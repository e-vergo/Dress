/-
Copyright (c) 2025 Dress contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
-/
import Lean
import SubVerso.Highlighting
import Dress.Capture.State
import Dress.Capture.InfoTree
import Dress.Serialize.Artifacts
import Dress.Serialize.Json
import Dress.Serialize.Html
import Dress.Highlighting

/-!
# Module-Level Output Generation

This module provides functions for generating module-level output files:
- Module header .tex files (for leanblueprint)
- Module-level JSON export

## Module Header Format

The module header .tex file defines:
- `\newleannode{label}{\input{path}}` for each declaration
- `\newleanmodule{module}{...}` with all `\inputleannode` calls
-/

open Lean Elab Command
open SubVerso.Highlighting

namespace Dress.Generate

/-- LaTeX preamble for module header files.
    Defines \newleannode, \inputleannode, \newleanmodule, \inputleanmodule macros. -/
private def moduleHeaderPreamble : String :=
  "%%% This file is automatically generated by Dress. %%%

%%% Macro definitions for \\inputleannode, \\inputleanmodule %%%

\\makeatletter

% \\newleannode{name}{latex} defines a new Lean node
\\providecommand{\\newleannode}[2]{%
  \\expandafter\\gdef\\csname leannode@#1\\endcsname{#2}}
% \\inputleannode{name} inputs a Lean node
\\providecommand{\\inputleannode}[1]{%
  \\csname leannode@#1\\endcsname}

% \\newleanmodule{module}{latex} defines a new Lean module
\\providecommand{\\newleanmodule}[2]{%
  \\expandafter\\gdef\\csname leanmodule@#1\\endcsname{#2}}
% \\inputleanmodule{module} inputs a Lean module
\\providecommand{\\inputleanmodule}[1]{%
  \\csname leanmodule@#1\\endcsname}

\\makeatother

%%% Start of main content %%%"

/-- Generate the module header .tex file content.
    Uses declarations tracked in texGeneratedDeclsRef. -/
def generateModuleHeader (moduleName : Name) : IO String := do
  let decls ← Capture.getTrackedDeclarations

  -- Build path to artifacts dir using forward slashes for LaTeX compatibility
  -- Use ../../ prefix: plastex runs from blueprint/, tex files are in blueprint/src/
  -- so ../../ goes from blueprint/src/ to project root
  let modulePathComponents := moduleName.components.map (·.toString)
  let artifactsDirPath := "../../.lake/build/blueprint/module/" ++
    "/".intercalate modulePathComponents ++ ".artifacts"

  -- Generate \newleannode entries
  let nodeEntries := decls.map fun (_, label) =>
    let sanitizedLabel := label.replace ":" "-"
    let inputPath := artifactsDirPath ++ "/" ++ sanitizedLabel
    s!"\\newleannode\{{label}}\{\\input\{{inputPath}}}"

  -- Generate \inputleannode entries for module content
  let inputEntries := decls.map fun (_, label) =>
    s!"\\inputleannode\{{label}}"

  let moduleContent := "\n\n".intercalate inputEntries.toList
  let moduleLatex := s!"\\newleanmodule\{{moduleName}}\{\n{moduleContent}\n}"

  return moduleHeaderPreamble ++ "\n\n" ++ "\n\n".intercalate nodeEntries.toList ++ "\n\n" ++ moduleLatex

/-- Write the module header .tex file.
    Called at module finalization when dressing is enabled.

    Writes to `.lake/build/blueprint/module/{Module/Path}.tex` -/
def writeModuleHeader (moduleName : Name) : IO Unit := do
  let decls ← Capture.getTrackedDeclarations
  -- Only write if we have declarations
  if decls.isEmpty then return

  let content ← generateModuleHeader moduleName

  -- Build path: .lake/build/blueprint/module/{Module/Path}.tex
  let baseDir : System.FilePath := ".lake" / "build" / "blueprint" / "module"
  let modulePath := moduleName.components.foldl (init := baseDir)
    fun path component => path / component.toString
  let headerPath := System.FilePath.addExtension modulePath "tex"

  -- Create directory and write file
  if let some parent := headerPath.parent then
    IO.FS.createDirAll parent
  IO.FS.writeFile headerPath content

/-- Get the output path for a module's dressed JSON file.
    Returns `.lake/build/dressed/{Module/Path}.json` -/
def getDressedOutputPath (buildDir : System.FilePath) (moduleName : Name) : System.FilePath :=
  let modulePath := moduleName.components.foldl (init := buildDir / "dressed")
    fun path component => path / component.toString
  modulePath.withExtension "json"

/-- Get the output path for a module's SubVerso-compatible JSON file.
    Returns `.lake/build/dressed/{Module/Path}.subverso.json` -/
def getSubVersoOutputPath (buildDir : System.FilePath) (moduleName : Name) : System.FilePath :=
  let modulePath := moduleName.components.foldl (init := buildDir / "dressed")
    fun path component => path / component.toString
  modulePath.withExtension "subverso.json"

/-- Get the output path for a module's HTML JSON file.
    Returns `.lake/build/dressed/{Module/Path}.html.json` -/
def getHighlightingHtmlOutputPath (buildDir : System.FilePath) (moduleName : Name) : System.FilePath :=
  let modulePath := moduleName.components.foldl (init := buildDir / "dressed")
    fun path component => path / component.toString
  modulePath.withExtension "html.json"

/-- Export all captured artifacts for the current module.
    Call this when module compilation completes.

    Writes to:
    - `.lake/build/dressed/{Module/Path}.json` - Full dressed artifacts
    - `.lake/build/dressed/{Module/Path}.subverso.json` - SubVerso format
    - `.lake/build/dressed/{Module/Path}.html.json` - HTML map
    - `.lake/build/blueprint/module/{Module/Path}.tex` - Module header .tex file -/
def exportModuleHighlighting (buildDir : System.FilePath) : CommandElabM Unit := do
  let env ← getEnv
  let moduleName := env.header.mainModule
  let highlighting := Capture.getModuleHighlighting env

  if highlighting.isEmpty then
    trace[blueprint.debug] "No highlighting to export for {moduleName}"
    return

  trace[blueprint] "Exporting {highlighting.size} dressed declarations for {moduleName}"

  -- Write dressed format (new unified format with base64 strings)
  try
    let path := getDressedOutputPath buildDir moduleName
    Serialize.writeDressedArtifacts path highlighting
    trace[blueprint] "Wrote dressed artifacts for {moduleName}"
  catch e =>
    let errMsg ← e.toMessageData.toString
    IO.eprintln s!"[blueprint] Failed to write dressed artifacts for {moduleName}: {errMsg}"
    trace[blueprint] "Failed to write dressed artifacts for {moduleName}: {e.toMessageData}"

  -- Write SubVerso format (backward compatibility)
  try
    let path := getSubVersoOutputPath buildDir moduleName
    Serialize.writeJsonAtomic path (Serialize.highlightingMapToModuleJson highlighting)
    trace[blueprint] "Wrote SubVerso JSON for {moduleName}"
  catch e =>
    trace[blueprint] "Failed to write SubVerso JSON for {moduleName}: {e.toMessageData}"

  -- Write HTML format (backward compatibility)
  try
    let path := getHighlightingHtmlOutputPath buildDir moduleName
    Serialize.writeHighlightingHtml path highlighting
    trace[blueprint] "Wrote highlighting HTML for {moduleName}"
  catch e =>
    let errMsg ← e.toMessageData.toString
    IO.eprintln s!"[blueprint] Failed to write highlighting HTML for {moduleName}: {errMsg}"
    trace[blueprint] "Failed to write highlighting HTML for {moduleName}: {e.toMessageData}"

  -- Write module header .tex file (for blueprint LaTeX integration)
  try
    writeModuleHeader moduleName
    trace[blueprint] "Wrote module header .tex for {moduleName}"
  catch e =>
    let errMsg ← e.toMessageData.toString
    IO.eprintln s!"[blueprint] Failed to write module header for {moduleName}: {errMsg}"
    trace[blueprint] "Failed to write module header for {moduleName}: {e.toMessageData}"

end Dress.Generate

-- Re-export at Dress namespace for backward compatibility
namespace Dress

abbrev generateModuleHeader := Generate.generateModuleHeader
abbrev writeModuleHeader := Generate.writeModuleHeader
abbrev exportModuleHighlighting := Generate.exportModuleHighlighting

end Dress
